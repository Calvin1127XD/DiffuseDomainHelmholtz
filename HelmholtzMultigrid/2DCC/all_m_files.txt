<FDOperator.m>
function operatorResult = FDOperator(u,DeW,DnS,C,hf)

nfPlusGhostLayers = size(u);
nf = nfPlusGhostLayers-2;

nx = nf(1);
ny = nf(2);
hf2 = hf*hf;

% Vectorized Code for the operator:
%
% - div(D grad(u)) + C(x) u 
%
% Compute east-west and north-south fluxes:
feW(1:nx+1,1:ny) = DeW(1:nx+1,1:ny).*(u(2:nx+2,2:ny+1)...
                   -u(1:nx+1,2:ny+1));
fnS(1:nx,1:ny+1) = DnS(1:nx,1:ny+1).*(u(2:nx+1,2:ny+2)...
                   -u(2:nx+1,1:ny+1));

% Compute the divergence of the fluxes and add reaction 
% term:
operatorResult(1:nx,1:ny) =...
                 -(feW(2:nx+1,1:ny)-feW(1:nx,1:ny)...
                 +fnS(1:nx,2:ny+1)-fnS(1:nx,1:ny))/hf2...
                 +C.*u(2:nx+1,2:ny+1);

end--------------
<MGOperator.m>
function u = MGOperator(level,f,DeW,DnS,C,u,hf,MGParam)

% Pre-smoothing
u = smoothQJacDamped(f,DeW,DnS,C,u,hf,MGParam.m1,...
                     MGParam.omega);

% Alternative pre-smoothing option:
% u = smoothQGSDamped(f,DeW,DnS,C,u,hf,MGParam.m1,...
%                     MGParam.omega,'fwd');

if level > 0
  hc = 2*hf;
  nfPlusGhost = size(u);
  nf = nfPlusGhost-2;

  % Coarse grid interior dimensions are [nc(1),nc(2)].
  nc = nf/2;

  % Compute the residual and restric to the coarse grid.
  cGr = restriction(getResidual(u,f,DeW,DnS,C,hf));
    
  % Restrict the diffusion coefficients to the coarse 
  % grid.
  [cDeW,cDnS] = restrictDiff(DeW,DnS);
  
  % Restrict the reaction coefficient to the coarse grid.
  cC = restriction(C);
    
  % Approximate on the coarse grid using recursive MG.
  cGc = zeros(nc(1)+2,nc(2)+2);
  for s = 1:MGParam.pCycle
    cGc =...
        MGOperator(level-1,cGr,cDeW,cDnS,cC,cGc,hc,MGParam);
  end

  % Prolongate the coarse grid correction and update the
  % fine grid approximation.
  u(2:nf(1)+1,2:nf(2)+1) = u(2:nf(1)+1,2:nf(2)+1)...
                 +prolongation(cGc(2:nc(1)+1,2:nc(2)+1));
    
  % Post-smoothing.
  u = smoothQJacDamped(f,DeW,DnS,C,u,hf,MGParam.m2,...
                       MGParam.omega);

  % Alternative post-smoothing option:
  % u = smoothQGSDamped(f,DeW,DnS,C,u,hf,MGParam.m2,...
  %                     MGParam.omega,'bwd');
end

end--------------
<applyBCs.m>
function u = applyBCs(u)

nfPlusGhostLayers = size(u);
nf = nfPlusGhostLayers-2;

% Homogeneous Dirichlet BC:

% u(2:nf(1)+1,        1) = -u(2:nf(1)+1,        2);
% u(2:nf(1)+1,  nf(2)+2) = -u(2:nf(1)+1,  nf(2)+1);
% u(        1,1:nf(2)+2) = -u(        2,1:nf(2)+2);
% u(  nf(1)+2,1:nf(2)+2) = -u(  nf(1)+1,1:nf(2)+2);

% Homogeneous Neumann BC:

u(2:nf(1)+1,        1) = u(2:nf(1)+1,        2);
u(2:nf(1)+1,  nf(2)+2) = u(2:nf(1)+1,  nf(2)+1);
u(        1,1:nf(2)+2) = u(        2,1:nf(2)+2);
u(  nf(1)+2,1:nf(2)+2) = u(  nf(1)+1,1:nf(2)+2);

% Periodic BC:

% u(2:nf(1)+1,        1) = u(2:nf(1)+1,  nf(2)+1);
% u(2:nf(1)+1,  nf(2)+2) = u(2:nf(1)+1,        2);
% u(        1,1:nf(2)+2) = u(  nf(1)+1,1:nf(2)+2);
% u(  nf(1)+2,1:nf(2)+2) = u(        2,1:nf(2)+2);

end--------------
<elliptic2DMGCCDiff.m>
%
%   elliptic2DMGCCDiff.m
%
% Calling script for solving the 2D elliptic equation
%
%   -div(D grad(u)) + C(x) u = f
%
% on a rectangular domain, where D is a possibly 
% non-constant, everywhere positive diffusion 
% coefficient, and C(x) is a non-negative function. The 
% boundary conditions may be taken to be 
% (i) homogeneous Dirichlet, (ii) homogeneous Neumann, 
% or (iii) periodic. See the function applyBCs.
% 
% Discretization is accomplished using the cell-centered 
% finite difference method. The cell-centered multigrid 
% method is used as the solver.
%
% If C(x) is zero everywhere, then homogeneous Dirichlet
% boundary conditions must be chosen.
%
%% Initialization and Parameter

% Clear command line window and workspace.
clear; clc;

% Tolerance of residual to stop multigrid iterations.
tol = 1.0e-09;

% Number of interior cells in x,y at finest level.
nL = [1024,1024]; 

% Number of multigrid levels.
L = 10;            

% Define the domain of the equation.
xLower = [0.0,0.0];
xUpper = [1.0,1.0];

hLvec = (xUpper-xLower)./nL;

% Parameters for the multigrid solver.
pCycle = 1;
m1     = 3;
m2     = 3;
omega  = 2/3;
kMax   = 100;

%% Setting up the multigrid solver

% Check mesh spacing.
if abs(hLvec(1)-hLvec(2)) > 1.0e-14
  error('Grid spacing mismatch in x vs y');
end
hL = hLvec(1);

% Check that nL is divisible by 2^(L-1).
nl = nL;
for k = L-1:-1:0
  if any(mod(nl,2) ~= 0)
    error('nL not divisible by 2^L.  Coarsening error.');
  end
  nl = nl/2;
end

MGParam.nL     = nL;
MGParam.xLower = xLower;
MGParam.xUpper = xUpper;
MGParam.L      = L;
MGParam.pCycle = pCycle;
MGParam.m1     = m1;
MGParam.m2     = m2;
MGParam.omega  = omega;
MGParam.kMax   = kMax;
MGParam.tol    = tol;

% Allocate solution arrays (with ghost layers).
u      = zeros(nL(1)+2,nL(2)+2);
uExact = zeros(nL(1)+2,nL(2)+2);
f      = zeros(nL(1)  ,nL(2)  );
xCC    = zeros(nL(1)  ,nL(2)  );
yCC    = zeros(nL(1)  ,nL(2)  );
DeW    = zeros(nL(1)+1,nL(2)  );
DnS    = zeros(nL(1)  ,nL(2)+1);
C      = zeros(nL(1)  ,nL(2)  );

% Build an exact solution and define f accordingly, 
% so we can test the true algebraic error.
for i = 1:nL(1)
  x = (i-0.5)*hL+xLower(1);
  xArg = 3.0*pi*x/xUpper(1);
  for j = 1:nL(2)
    y = (j-0.5)*hL+xLower(2);
    yArg = 3.0*pi*y/xUpper(2);
    uExact(i+1,j+1) = exp(cos(xArg)*cos(yArg));
    xCC(i,j) = x;
    yCC(i,j) = y;
  end
end

% We next build the finest-grid diffusion 
% arrays DeW, DnS:
for i = 1:nL(1)+1
  xEdge = (i-1.0)*hL+xLower(1);
  xArg = 2.0*pi*xEdge/xUpper(1);
  for j = 1:nL(2)
    yEdge = (j-0.5)*hL+xLower(2);
    yArg = 2.0*pi*yEdge/xUpper(2);

% Evaluate D at the east-west edge point:
    DeW(i,j) = 1.0+0.5*sin(xArg)*cos(yArg);
  end
end

for i = 1:nL(1)
  xEdge = (i-0.5)*hL+xLower(1);
  xArg = 2.0*pi*xEdge/xUpper(1);
  for j = 1:nL(2)+1
    yEdge = (j-1.0)*hL+xLower(2);
    yArg = 2.0*pi*yEdge/xUpper(2);
    
% Evaluate D at the north-south edge point:
    DnS(i,j) = 1.0+0.5*sin(xArg)*cos(yArg);
  end
end

% Define the reaction coefficient C(x) at the cell centers.
C = 3 + sin(2.0*pi*xCC/xUpper(1)).*sin(2.0*pi*yCC/xUpper(2));

% Store C in the MGParam struct
MGParam.C = C;

% Apply the BCs to uExact, then compute f by calling 
% FDOperator.
uExact = applyBCs(uExact);
f = FDOperator(uExact,DeW,DnS,C,hL);

%% Call the Multigrid solver.

tic;
[u,errVals,kStop] = multiGridSolver(u,f,DeW,DnS,C,hL,...
                                    MGParam,uExact);
toc;

%% Plotting the numerical solution and error plots.

uPlot(1:nL(1),1:nL(2)) = u(2:nL(1)+1,2:nL(2)+1);

figure(1)
clf

surf(xCC,yCC,uPlot,'EdgeColor','none');
title('Numerical Solution u');
xlabel('x');
ylabel('y');
zlabel('u(x,y)');
colorbar;
view(2);
axis equal tight;

figure(2)
clf
semilogy(errVals(1:kStop,3),'bo','LineWidth',1.5)
hold on
semilogy(errVals(1:kStop,2),'rs','LineWidth',1.5)
hold on
semilogy(errVals(1:kStop,1),'kd','LineWidth',1.5)
hold on

rate = 1.0;
if kStop >= 4
  kv = kStop-3:kStop;
  le = log(errVals(kStop-3:kStop,3));
  p1 = polyfit(kv,le,1);
  rate = exp(p1(1));
  p1k = polyval(p1,1:kStop);
  semilogy(1:kStop,exp(p1k),'-k')
else
  semilogy(errVals(1:kStop,1),'.','LineWidth',1.5)
end

xlabel('$k$','Interpreter','latex');
title('Multigrid Iteration Errors',...
  'Interpreter','latex');
legend(...
  '$\left\|{\bf u}_L^{\rm E}-{\bf u}_L^k\right\|_L$',...
  '$\left\|{\bf u}_L^k-{\bf u}_L^{k-1} \right\|_L$',...
  '$\left\|{\bf r}_L^k\right\|_L$',...
  'log-linear fit','Interpreter','latex');
text(1.5,128*MGParam.tol,strcat(...
  '$\gamma_{\rm comp} =\hspace{.1cm}$',...
  num2str(rate,'%10.5e')),'FontSize',14,...
  'Interpreter','latex')
text(1.5,32*MGParam.tol,strcat('$m_1 =\hspace{.1cm}$',...
  num2str(MGParam.m1)),'FontSize',14,...
  'Interpreter','latex')
text(1.5,8*MGParam.tol,strcat('$m_2 =\hspace{.1cm}$',...
  num2str(MGParam.m2)),'FontSize',14,...
  'Interpreter','latex')
text(1.5,2*MGParam.tol,strcat('$p =\hspace{.1cm}$',...
  num2str(MGParam.pCycle)),'FontSize',14,...
  'Interpreter','latex')
text(1.5,0.5*MGParam.tol,...
  strcat('$\omega =\hspace{.1cm}$',...
  num2str(MGParam.omega)),'FontSize',14,...
  'Interpreter','latex')
printstr = strcat('Err_nL_',num2str(MGParam.nL(1)),...
  '_m1_',num2str(MGParam.m1),'.pdf');
exportgraphics(gca, printstr)
hold off--------------
<getResidual.m>
function residualResult = getResidual(u,f,DeW,DnS,C,hf)

% Apply the boundary conditions
u = applyBCs(u);

residualResult = f-FDOperator(u,DeW,DnS,C,hf);

end--------------
<multiGridSolver.m>
function [u,errVals,kStop] =...
          multiGridSolver(u0,f,DeW,DnS,C,hf,MGParam,uExact)

nf = size(f);
k = 0;
errorVal = MGParam.tol+1.0;
errVals = zeros(MGParam.kMax,3);

uo = u0;

while ((k < MGParam.kMax) && (errorVal > MGParam.tol))

  % Apply one multigrid cycle.
  u = MGOperator(MGParam.L,f,DeW,DnS,C,uo,hf,MGParam);

  % Evaluate various norms.
  residErr =...
            normScaledL2(getResidual(u,f,DeW,DnS,C,hf));
  correErr = normScaledL2(uo(2:nf(1)+1,2:nf(2)+1)...
                          -u(2:nf(1)+1,2:nf(2)+1));
  exactErr = normScaledL2(uExact(2:nf(1)+1,2:nf(2)+1)...
                          -u(2:nf(1)+1,2:nf(2)+1));

  k = k+1;
  errVals(k,1) = residErr;
  errVals(k,2) = correErr;
  errVals(k,3) = exactErr;

  fprintf('Multigrid iteration %d:\n', k);
  fprintf('  residual   = %.6e\n', residErr);
  fprintf('  correction = %.6e\n', correErr);
  fprintf('  true error = %.6e\n', exactErr);

  % Stopping criterion (artificial, for demonstration).
  errorVal = exactErr;  
  uo = u;
end

kStop = k;

end--------------
<normScaledL2.m>
function normResult = normScaledL2(u)

nf = size(u);
normResult = sqrt(sum(sum(u.*u))/(nf(1)*nf(2)));

end--------------
<prolongation.m>
function presult = prolongation(u)

nc = size(u);
nf = nc*2;
presult = zeros(nf);

presult(2:2:nf(1)  ,2:2:nf(2)  ) = u(1:nc(1),1:nc(2));
presult(1:2:nf(1)-1,2:2:nf(2)  ) = u(1:nc(1),1:nc(2));
presult(2:2:nf(1)  ,1:2:nf(2)-1) = u(1:nc(1),1:nc(2));
presult(1:2:nf(1)-1,1:2:nf(2)-1) = u(1:nc(1),1:nc(2));

end--------------
<restrictDiff.m>
function [cDeW,cDnS] = restrictDiff(DeW,DnS)

[nxEW,ny] = size(DeW);
[nx,nyNS] = size(DnS);

ncx = nx/2;  
ncy = ny/2;

cDeW(1:ncx+1,1:ncy) =...
       0.5*(DeW(1:2:nx+1,1:2:ny-1)+DeW(1:2:nx+1,2:2:ny));

cDnS(1:ncx,1:ncy+1) =...
       0.5*(DnS(1:2:nx-1,1:2:ny+1)+DnS(2:2:nx,1:2:ny+1));

end--------------
<restriction.m>
function restrictionResult = restriction(u)

nf = size(u);
nc = nf/2;
restrictionResult...
  = 0.25*(u(1:2:nf(1)-1,1:2:nf(2)-1)...
    +     u(2:2:nf(1)  ,1:2:nf(2)-1)...
    +     u(1:2:nf(1)-1,2:2:nf(2)  )...
    +     u(2:2:nf(1)  ,2:2:nf(2)  ));

end--------------
<smoothQGSDamped.m>
function u = smoothQGSDamped(f,DeW,DnS,C,u,hf,m,...
  omega,sweepDirection)

nfPlusGhostLayers = size(u);
nf = nfPlusGhostLayers-2;

hf2 = hf*hf;
omegaPrime = 1.0-omega;

switch sweepDirection
  case 'fwd'
    xSweepIndex = [1:nf(1)];
    ySweepIndex = [1:nf(2)];
  otherwise
    xSweepIndex = [nf(1):-1:1];
    ySweepIndex = [nf(2):-1:1];
end

u = applyBCs(u);

for sweep = 1:m
  for j = ySweepIndex
    for i = xSweepIndex

      tmp = (hf2*f(i,j)...
            +u(i+2,j+1)*DeW(i+1,j  )...
            +u(i  ,j+1)*DeW(i  ,j  )...
            +u(i+1,j+2)*DnS(i  ,j+1)...
            +u(i+1,j  )*DnS(i  ,j  ))...
            /(DeW(i+1,j)+DeW(i,j)+DnS(i,j+1)+DnS(i,j)...
            +C(i,j)*hf2);
      u(i+1,j+1) = omega*tmp+omegaPrime*u(i+1,j+1);

    end
  end
  
  u = applyBCs(u);

end

end--------------
<smoothQJacDamped.m>
function u = smoothQJacDamped(f,DeW,DnS,C,u,hf,m,omega)

nfPlusGhostLayers = size(u);
nf = nfPlusGhostLayers-2;

z = zeros(nf(1),nf(2));

hf2 = hf*hf;
omegaPrime = 1.0-omega;

u = applyBCs(u);

for sweep = 1:m
  for j = 1:nf(2)
    for i = 1:nf(1)

      z(i,j) = (hf2*f(i,j)...
               +u(i+2,j+1)*DeW(i+1,j  )...
               +u(i  ,j+1)*DeW(i  ,j  )...
               +u(i+1,j+2)*DnS(i  ,j+1)...
               +u(i+1,j  )*DnS(i  ,j  ))...
               /(DeW(i+1,j)+DeW(i,j)+DnS(i,j+1)...
               +DnS(i,j)+ C(i,j)*hf2);

    end
  end

  u(2:nf(1)+1,2:nf(2)+1) = omega*z(1:nf(1),1:nf(2))...
    + omegaPrime*u(2:nf(1)+1,2:nf(2)+1);
  u = applyBCs(u);

end

end--------------
